<html>
<head>
    <link href="../css/elroi.css" rel="stylesheet" type="text/css">

    <style type="text/css">

            /* @group --proxima */

        @font-face {
            font-family: 'proxima bold';
            src: url('https://proto.opower.com/astro-UAT/resources/type/proxima_nova_bold-webfont.eot');
            src: local('â˜º'),
            url('https://proto.opower.com/astro-UAT/resources/type/proxima_nova_bold-webfont.woff') format('woff'),
            url('https://proto.opower.com/astro-UAT/resources/type/proxima_nova_bold-webfont.ttf') format('truetype'),
            url('https://proto.opower.com/astro-UAT/resources/type/proxima_nova_bold-webfont.svg#webfontNvixsUFI') format('svg');
            font-weight: bold;
            font-style: normal;
        }

        @font-face {
            font-family: 'proxima';
            src: url('https://proto.opower.com/astro-UAT/resources/type/proxima_nova_reg-webfont.eot');
            src: local('â˜º'),
            url('https://proto.opower.com/astro-UAT/resources/type/proxima_nova_reg-webfont.woff') format('woff'),
            url('https://proto.opower.com/astro-UAT/resources/type/proxima_nova_reg-webfont.ttf') format('truetype'),
            url('https://proto.opower.com/astro-UAT/resources/type/proxima_nova_reg-webfont.svg#webfontbD9XVJdx') format('svg');
            font-weight: normal;
            font-style: normal;
        }

            /* @end */

    </style>

    <script type="text/javascript" src="../vendor/jquery/jquery.js"></script>
    <script type="text/javascript" src="../vendor/raphael/raphael-2.1.0.js"></script>

    <script type="text/javascript" src="../elroi.js"></script>
    <script type="text/javascript">

    var testSeries = [[{value: 35, name: 'Cooling', color: '#1087C9'},
        {value: 19, name: 'Heating', color: '#AB3E2C'},
        {value: 15, name: 'Hot Water', color: '#663366'},
        {value: 15, name: 'Appliances', color: '#C2B59B'},
        {value: 10, name: 'Lighting', color: '#65D9C5'},
        {value: 5, name:'Other', color: '#8FC740'}]];

    var testSeries2 = [[{value: 15, name: 'Cooling', color: '#1087C9'},
        {value: 15, name: 'Heating', color: '#AB3E2C'},
        {value: 15, name: 'Hot Water', color: '#663366'},
        {value: 15, name: 'Appliances', color: '#C2B59B'},
        {value: 15, name: 'Lighting', color: '#65D9C5'},
        {value: 15, name:'Other', color: '#8FC740'}]];


    var astroSpinningPie = (function($){
            var ns = {};

            /* Mode enumeration*/
            var Mode = {
                INITIAL: 'initial',
                SURVEY: 'survey',
                COMPLETE: 'complete',
                SELECTED: 'selected'
            };

            ns.Mode = Mode;

            /* Member variables */
            /* Workflow */
            var sectionsCompleted = 0, //Used to keep track of progress during survey section
                    mode = Mode.INITIAL,
                    selectedWedge = null;

            /* From elroi */
            var graph = null, //Graph generated by calling elroi
                wedges = null, //All of the pie wedges alias for graph.wedges
                pie = null; //Additional pie only functions associated with this pie provided by elroi, alias for graph.context

            /*Center circle */
            var circle = null,
                currentText = null;

            /* Configurable variables */
            var BUMP_OUT_RADIUS = 210,
                STANDARD_RADIUS = 200,
                BASE_COLORS = ['#1087C9','#AB3E2C','#663366','#C2B59B','#65D9C5','#8FC740'],
                BASE_FONT = {'font-family':'proxima','font-weight':'bold','fill': 'black'};

            /* Message methods
             * Generates message text for a specific wedge based on Mode.
             * @param paper {object} Raphael paper that our graph is drawn on
             * @param centerX {number} Center x coordinate of our Raphael graph
             * @param centerY {number} Center y coordinate of our Raphael graph
             * @param wedgeIndex {number} Index of the wedge in wedges used for the message
             * @param wedgeData {object} Data tied to this wedge, can be set through the series data
             */
            /* Mode.COMPLETE text generator */
            function completeMessage (paper,centerX,centerY,wedgeIndex,wedgeData) {
                currentText.push(
                        paper.text(centerX,centerY-20,wedgeData.value+'%')
                                .attr(BASE_FONT).attr({'font-size':55}),
                        paper.text(centerX,centerY+20,wedgeData.name)
                                .attr(BASE_FONT).attr({'font-size':25,'fill': wedges[wedgeIndex].attrs.fill})
                );
            }

            /* Mode.INITIAL text generator */
            function initialMessage(paper,centerX,centerY,wedgeIndex,wedgeData) {
                currentText.push(
                        paper.text(centerX,centerY-20,wedgeData.name)
                                .attr(BASE_FONT).attr({'font-size':25}),
                        paper.text(centerX,centerY+15,wedgeData.value+'% is the average used\n by utility customers.')
                                .attr(BASE_FONT).attr({'font-size':14})
                );
            }

            /* Mode.SURVEY text generator */
            function surveyMessage(paper,centerX,centerY,wedgeIndex,wedgeData) {
                if(wedgeIndex < sectionsCompleted) {
                    completeMessage(paper,centerX,centerY,wedgeIndex,wedgeData);
                }
                else {
                    currentText.push(
                            paper.text(centerX,centerY-20,wedgeData.name)
                                    .attr(BASE_FONT).attr({'font-size':25})
                                    .attr((wedgeIndex==sectionsCompleted) ? {fill: wedgeData.color } : {}),
                            paper.text(centerX,centerY+15, (wedgeIndex==sectionsCompleted) ? 'In progress' : 'Not started')
                                    .attr(BASE_FONT)
                                    .attr({'font-size':14})
                    );
                }
            }

            /* Message helper methods */

            /**
             * Removes the current message text and creates a new Raphael set for the next message.
             */
            function resetMessageText() {
                if(currentText != null)
                    currentText.remove();
                currentText = graph.paper.set();
            }

            /**
             * Helper function to show or hide the message circle.
             * @param show {boolean} indicates whether or not to display the message circle.
             */
            function showMessage(show){
                if(!show) csWedge = null;
                circle.attr({opacity: show ? 1 : 0});
            }

            /* Section initialization methods */

            /* Mode.SURVEY specific initialization, called by changeMode */
            function surveyInitialize(){
                for(var x = sectionsCompleted-1; x >= 0; x--)
                    wedges[x].attr({fill: BASE_COLORS[x]});

                for(var x = sectionsCompleted+1; x < wedges.length; x++)
                    wedges[x].attr({fill: '#dddddd'});

                wedges[sectionsCompleted].attr(descriptors[Mode.SURVEY].highlightAttr);
            }

            /* Mode.COMPLETE specific initialization, called by changeMode */
            function completeInitialize(){
                selectedWedge = null;
                pie.updateColors(BASE_COLORS);
            }

            /**
             * Event generated by the wedgeClick event alerting that the selected wedge has changed.  Depending on mode,
             * there may be specific logic to handle this event.
             * @param previousSelectedWedge {object} the old wedge selection
             * @param selectedWedge {object} the new wedge selection
             */
            function selectedWedgeChanged (previousSelectedWedge, selectedWedge){

                /**
                 * Highlight the newly selected wedge by changing its opacity to 1 and lowering the opacity of
                 * nonselected wedges.
                 */
                function highlightSelected(){
                    for(var x = 0; x < wedges.length; x+=1) {
                        if(selectedWedge != null && wedges[x] != selectedWedge){
                            wedges[x].animate({opacity:.5}, 25);
                        }
                        else {
                            wedges[x].animate({opacity: 1}, 25);
                        }
                    }
                    regenerateTransformedWedgePaths();
                }

                mode = Mode.SELECTED;
                if(previousSelectedWedge != null) {
                    previousSelectedWedge.attr(descriptors[mode].attr);
                }

                pie.rotateToWedge(selectedWedge, highlightSelected);
            }

            /* Workflow descriptors that correspond to each mode */
            var descriptors = {
                initial:
                {
                    hover: {handles: true, attr: {fill: '#888888', radius: BUMP_OUT_RADIUS}},
                    attr: {fill: '#dddddd', radius: STANDARD_RADIUS, opacity: 1},
                    text: initialMessage
                },
                survey:
                {
                    hover: {handles: true, attr: {radius: BUMP_OUT_RADIUS}},
                    attr: {radius: STANDARD_RADIUS, opacity: 1},
                    highlightAttr: {fill: '#888888', radius: BUMP_OUT_RADIUS},
                    init: surveyInitialize,
                    text: surveyMessage
                },
                complete:
                {
                    hover: {handles: true, attr: {radius: BUMP_OUT_RADIUS}},
                    click: {handles: true},
                    selected: {selectionChanged: selectedWedgeChanged},
                    attr: {radius: STANDARD_RADIUS, opacity: 1},
                    init: completeInitialize,
                    text: completeMessage
                },
                selected:
                {
                    hover: {handles: true, attr: {radius: BUMP_OUT_RADIUS}},
                    click: {handles: true},
                    selected: {selectionChanged: selectedWedgeChanged, showTextAsDefault: true},
                    highlighAttr: {radius: BUMP_OUT_RADIUS},
                    attr: {radius: STANDARD_RADIUS, opacity:.5},
                    text: completeMessage
                }
            }

            /* Elroi event callbacks */

            /**
             * Click hook to provide to advancedPie elroi graph.  Calls a handler determined by the provided
             * descriptors for the current mode.
             * @param wedge {object} the wedge that is the target of the event, provided by elroi
             */
            var wedgeClick = function(wedge){
                if(!descriptors[mode].click) {
                    return;
                }

                resetMessageText();
                showMessage(false);

                if(selectedWedge == wedge){
                    return;
                }
                else if(descriptors[mode].selected.selectionChanged){
                    var previouslySelectedWedge = selectedWedge;
                    selectedWedge = wedge;

                    descriptors[mode].selected.selectionChanged(previouslySelectedWedge, selectedWedge);
                }
            }

            /**
             * Hover enter hook to provide to advancedPie elroi graph.  Calls a handler determined by the provided
             * descriptors for the current mode.
             * @param wedge {object} the wedge that is the target of the event, provided by elroi
             */
            var wedgeHoverIn = function(wedge){
                var index = -1;
                for(var x=0; x < wedges.length; x+=1) {
                    if(wedge === wedges[x]) {
                        index = x;
                    }
                }

                resetMessageText();

                showMessage(true);

                descriptors[mode].text(graph.paper,
                        graph.options.center.x,
                        graph.options.center.y,
                        index,
                        wedge.data
                );



                if(wedge==selectedWedge){
                    return;
                }

                wedge.animate(descriptors[mode].hover.attr, 150, 'bounce');
            }

            /**
             * Hover exit hook to provide to advancedPie elroi graph.  Calls a handler determined by the provided
             * descriptors for the current mode.
             * @param wedge {object} the wedge that is the target of the event, provided by elroi
             */
            var wedgeHoverOut = function(wedge) {
                currentText.attr({opacity: 0});
                showMessage(false);

                if(wedge==selectedWedge){
                    return;
                }

                wedge.animate(descriptors[mode].attr,150, 'bounce');
            }

            /* Public workflow and initialization */

            /**
             * Change the mode to Mode.SURVEY and to the selected section.
             * @param section {number} the number of sections to indicate as being completed.
             */
            ns.changeSection = function(section){
                if(isNaN(section)){
                    throw "Parameter section must be a number.";
                }

                sectionsCompleted = section;
                selectedWedge = wedges[sectionsCompleted];
                ns.changeMode(Mode.SURVEY);
            }

            /**
             * Change the mode of the workflow to a different descriptor state.  Make mode specific styling changes
             * and trigger mode specific init events.
             * @param newMode {enum} new mode from Mode enum to switch to.
             */
            ns.changeMode = function(newMode){
                mode = newMode;
                wedges.animate(descriptors[mode].attr, 25, function(){
                    if(descriptors[mode].init){
                        descriptors[mode].init();
                    }
                });
            }

        var csWedge = null;
        var updatedWedgePaths = new Array();
        function regenerateTransformedWedgePaths() {
            for(var x=0; x < wedges.length; x+=1) {
                var path = wedges[x].attrs.path.toString();
                for(var t = 0; t < wedges[x].attrs.transform.length; t+=1)
                    path = Raphael.transformPath(path, wedges[x].attrs.transform[t].toString());
                updatedWedgePaths[x] = path.toString();
            }
        }

            /**
             * Creates and initalizes an astroSpinningPie.
             * @param $container {object} jQuery object to place the elroi graph into
             */
            ns.initialize = function($container){
                pie = elroi($container, [{series:testSeries, options: {type:'advancedPie'}}],
                        {colors: ['#dddddd','#dddddd','#dddddd','#dddddd','#dddddd','#dddddd'],
                            //animation: false,
                            wedgeAttributes: {stroke: 'white', 'stroke-width': 3, cursor: 'pointer'},
                            hoverEvents: {wedgeHoverIn: wedgeHoverIn, wedgeHoverOut: wedgeHoverOut},
                            radius: 200,
                            wedgeClick: wedgeClick});

                graph = pie.graph;
                wedges = pie.graph.wedges;
                //context = pie.graph.context;


                var containerOffsetLeft = $($container).offset().left;
                var containerOffsetTop = $($container).offset().top;

                //var mpi180 = Math.PI / 180;

                circle = graph.paper
                        .circle(graph.options.center.x, graph.options.center.y, graph.options.radius /2)
                        .attr({fill: '#F5F5F5', stroke: 'white', 'stroke-width':3, opacity:0, cursor: 'pointer'})
                        .hover(function(){
                            circle.attr({opacity: 1});
                            currentText.attr({opacity: 1});},
                        function(){})
                        .mousemove(function(e){
                            var posx = e.clientX + $(document).scrollLeft() - $($container).offset().left;
                            var posy = e.clientY + $(document).scrollTop() - $($container).offset().top;

                            //console.log('POS:' + posx + ',' + posy);
                            //console.log('Scroll:' + $(document).scrollLeft() + ',' + $(document).scrollTop());
                            //console.log('Container:' + $($container).offset().left + ',' + $($container).offset().top);


                            /*

                            bs
                            cs2 3
                            int x = 0;


                            bs.P()

                            x++;
                            if(x == 3){
                              x = 0;
                              cs2.V(); cs.V();
                              }
                            else
                              cs2.P();

                            bs.V()





                             */

                            var newWedge = null;

                            if(updatedWedgePaths.length === 0)
                                regenerateTransformedWedgePaths();

                            for(var x=0; x < wedges.length; x+=1){
                                if(csWedge != null && newWedge === csWedge) {
                                   continue;
                                }
                                if(Raphael.isPointInsidePath(updatedWedgePaths[x],posx,posy)) {
                                    newWedge = wedges[x];
                                    break;
                                }
                            }

                            if(newWedge == null) console.log('no match');
                            if(newWedge === csWedge) console.log('same as before!');

                            if(newWedge != null && newWedge !== csWedge) //i != -1 &&
                            {
                                console.log('changing wedge');
                                if(csWedge) wedgeHoverOut(csWedge);
                                csWedge = newWedge;
                                wedgeHoverIn(newWedge);
                            }
                        }).click(function(){if(csWedge) wedgeClick(csWedge); });




            }

            /* CUT THESE HOOKS */

            ns.resetRotation = function(){
                pie.rotate(-90, function(){regenerateTransformedWedgePaths();});
            }

            ns.resizeLive = function (){
                pie.updateLive(testSeries2,0);
            }

           return ns;
        })(jQuery);



        $(document).ready(function(){
            astroSpinningPie.initialize($('#pie').find('.graph'));

            $('#deselect,#finish').click(function(){astroSpinningPie.changeMode(astroSpinningPie.Mode.COMPLETE);});

            $('#cooling1,#cooling2,#cooling3,#cooling4').click(function(){ astroSpinningPie.resetRotation(); astroSpinningPie.changeSection(0); });
            $('#heating1, #heating2').click(function(){ astroSpinningPie.resetRotation(); astroSpinningPie.changeSection(1); });
            $('#hotwater1').click(function(){ astroSpinningPie.resetRotation(); astroSpinningPie.changeSection(2); });
            $('#appliances1').click(function(){ astroSpinningPie.resetRotation(); astroSpinningPie.changeSection(3); });
            $('#lighting1').click(function(){ astroSpinningPie.resetRotation(); astroSpinningPie.changeSection(4); });
            $('#other1').click(function(){ astroSpinningPie.resetRotation(); astroSpinningPie.changeSection(5); });

            $('#rotateTo0').click(function(){ astroSpinningPie.resetRotation();  });

            $('#resize1').click(function(){ astroSpinningPie.resizeLive();  });
        });

    </script>

    <style>
        .sample { float: left; clear: both; margin-top: 30px; border-top: 1px solid #444;}
        .sample .graph { float: left; width: 550px; height: 450px; }
        .sample .graph .paper {width: 550px; height: 450px;}
        .sample pre { float: left; border: 1px solid #000; background: #ccc; margin-left: 20px; padding: 20px;}
    </style>
</head>
<body>
<h1>Disaggregated Spinning Pie Harness</h1>



    <div class="sample" id="pie">
        <h2>Pie Chart</h2>
        <div class="graph" style="float:left;"></div>
    <div style="float: left; width:450px; background-color: white; border: solid 1px black;"><div style="padding:10px;">
        <b>Workflow</b>
        <div>
            Cooling:
            <span id="cooling1" style="color:blue; cursor:pointer;">1</span>
            <span id="cooling2" style="color:blue; cursor:pointer;">2</span>
            <span id="cooling3" style="color:blue; cursor:pointer;">3</span>
            <span id="cooling4" style="color:blue; cursor:pointer;">4</span>
        </div>
        <div>
            Heating:
            <span id="heating1" style="color:blue; cursor:pointer;">1</span>
            <span id="heating2" style="color:blue; cursor:pointer;">2</span>
        </div>
        <div>
            Hot Water: <span id="hotwater1" style="color:blue; cursor:pointer;">1</span>
        </div>
        <div>
            Appliances: <span id="appliances1" style="color:blue; cursor:pointer;">1</span>
        </div>
        <div>
            Lighting: <span id="lighting1" style="color:blue; cursor:pointer;">1</span>
        </div>
        <div>
            Other: <span id="other1" style="color:blue; cursor:pointer;">1</span>
        </div>
        <div>
            Finish: <span id="finish" style="color:blue; cursor:pointer;">click</span>
        </div>

        <b>Miscellaneous</b>
        <div>
            Deselect: <span id="deselect" style="color:blue; cursor:pointer;">click</span>
        </div>
        <div>
            To Zero: <span id="rotateTo0" style="color:blue; cursor:pointer;">click</span>
        </div>
        <div>
            Resize Test 1: <span id="resize1" style="color:blue; cursor:pointer;">click</span>
        </div>
    </div></div>
    </div>


</body>
</html>